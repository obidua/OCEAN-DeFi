import{cD as T,cE as W,cF as x,cG as A,cH as g,cI as D,cJ as P,cK as B,cL as M,cM as F,cN as w,cO as v,cP as L,cQ as N,cR as z,cS as R,cT as _,cU as H,cV as V,cW as Q,cX as $}from"./index-BW9rm6a1.js";const I={getGasPriceInEther(n,t){const o=t*n;return Number(o)/1e18},getGasPriceInUSD(n,t,o){const s=I.getGasPriceInEther(t,o);return T.bigNumber(n).times(s).toNumber()},getPriceImpact({sourceTokenAmount:n,sourceTokenPriceInUSD:t,toTokenPriceInUSD:o,toTokenAmount:s}){const c=T.bigNumber(n).times(t),r=T.bigNumber(s).times(o);return c.minus(r).div(c).times(100).toNumber()},getMaxSlippage(n,t){const o=T.bigNumber(n).div(100);return T.multiply(t,o).toNumber()},getProviderFee(n,t=.0085){return T.bigNumber(n).times(t).toString()},isInsufficientNetworkTokenForGas(n,t){const o=t||"0";return T.bigNumber(n).eq(0)?!0:T.bigNumber(T.bigNumber(o)).gt(n)},isInsufficientSourceTokenForSwap(n,t,o){var r,d;const s=(d=(r=o==null?void 0:o.find(l=>l.address===t))==null?void 0:r.quantity)==null?void 0:d.numeric;return T.bigNumber(s||"0").lt(n)}},O=15e4,q=6,k={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,switchingTokens:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:_.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},e=x({...k}),E={state:e,subscribe(n){return $(e,()=>n(e))},subscribeKey(n,t){return Q(e,n,t)},getParams(){var i,u,p,f,S,h,y,b,C;const n=w.state.activeChain,t=((i=w.getAccountData(n))==null?void 0:i.caipAddress)??w.state.activeCaipAddress,o=L.getPlainAddress(t),s=H(),c=V.getConnectorId(w.state.activeChain);if(!o)throw new Error("No address found to swap the tokens from.");const r=!((u=e.toToken)!=null&&u.address)||!((p=e.toToken)!=null&&p.decimals),d=!((f=e.sourceToken)!=null&&f.address)||!((S=e.sourceToken)!=null&&S.decimals)||!T.bigNumber(e.sourceTokenAmount).gt(0),l=!e.sourceTokenAmount;return{networkAddress:s,fromAddress:o,fromCaipAddress:t,sourceTokenAddress:(h=e.sourceToken)==null?void 0:h.address,toTokenAddress:(y=e.toToken)==null?void 0:y.address,toTokenAmount:e.toTokenAmount,toTokenDecimals:(b=e.toToken)==null?void 0:b.decimals,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:(C=e.sourceToken)==null?void 0:C.decimals,invalidToToken:r,invalidSourceToken:d,invalidSourceTokenAmount:l,availableToSwap:t&&!r&&!d&&!l,isAuthConnector:c===P.CONNECTOR_ID.AUTH}},async setSourceToken(n){if(!n){e.sourceToken=n,e.sourceTokenAmount="",e.sourceTokenPriceInUSD=0;return}e.sourceToken=n,await a.setTokenPrice(n.address,"sourceToken")},setSourceTokenAmount(n){e.sourceTokenAmount=n},async setToToken(n){if(!n){e.toToken=n,e.toTokenAmount="",e.toTokenPriceInUSD=0;return}e.toToken=n,await a.setTokenPrice(n.address,"toToken")},setToTokenAmount(n){e.toTokenAmount=n?T.toFixed(n,q):""},async setTokenPrice(n,t){let o=e.tokensPriceMap[n]||0;o||(e.loadingPrices=!0,o=await a.getAddressPrice(n)),t==="sourceToken"?e.sourceTokenPriceInUSD=o:t==="toToken"&&(e.toTokenPriceInUSD=o),e.loadingPrices&&(e.loadingPrices=!1),a.getParams().availableToSwap&&!e.switchingTokens&&a.swapTokens()},async switchTokens(){if(!(e.initializing||!e.initialized||e.switchingTokens)){e.switchingTokens=!0;try{const n=e.toToken?{...e.toToken}:void 0,t=e.sourceToken?{...e.sourceToken}:void 0,o=n&&e.toTokenAmount===""?"1":e.toTokenAmount;a.setSourceTokenAmount(o),a.setToTokenAmount(""),await a.setSourceToken(n),await a.setToToken(t),e.switchingTokens=!1,a.swapTokens()}catch(n){throw e.switchingTokens=!1,n}}},resetState(){e.myTokensWithBalance=k.myTokensWithBalance,e.tokensPriceMap=k.tokensPriceMap,e.initialized=k.initialized,e.initializing=k.initializing,e.switchingTokens=k.switchingTokens,e.sourceToken=k.sourceToken,e.sourceTokenAmount=k.sourceTokenAmount,e.sourceTokenPriceInUSD=k.sourceTokenPriceInUSD,e.toToken=k.toToken,e.toTokenAmount=k.toTokenAmount,e.toTokenPriceInUSD=k.toTokenPriceInUSD,e.networkPrice=k.networkPrice,e.networkTokenSymbol=k.networkTokenSymbol,e.networkBalanceInUSD=k.networkBalanceInUSD,e.inputError=k.inputError},resetValues(){var o;const{networkAddress:n}=a.getParams(),t=(o=e.tokens)==null?void 0:o.find(s=>s.address===n);a.setSourceToken(t),a.setToToken(void 0)},getApprovalLoadingState(){return e.loadingApprovalTransaction},clearError(){e.transactionError=void 0},async initializeState(){if(!e.initializing){if(e.initializing=!0,!e.initialized)try{await a.fetchTokens(),e.initialized=!0}catch{e.initialized=!1,g.showError("Failed to initialize swap"),A.goBack()}e.initializing=!1}},async fetchTokens(){var o;const{networkAddress:n}=a.getParams();await a.getNetworkTokenPrice(),await a.getMyTokensWithBalance();const t=(o=e.myTokensWithBalance)==null?void 0:o.find(s=>s.address===n);t&&(e.networkTokenSymbol=t.symbol,a.setSourceToken(t),a.setSourceTokenAmount("0"))},async getTokenList(){var t,o;const n=(t=w.state.activeCaipNetwork)==null?void 0:t.caipNetworkId;if(!(e.caipNetworkId===n&&e.tokens))try{e.tokensLoading=!0;const s=await N.getTokenList(n);e.tokens=s,e.caipNetworkId=n,e.popularTokens=s.sort((i,u)=>i.symbol<u.symbol?-1:i.symbol>u.symbol?1:0);const r=(n&&((o=_.SUGGESTED_TOKENS_BY_CHAIN)==null?void 0:o[n])||[]).map(i=>s.find(u=>u.symbol===i)).filter(i=>!!i),l=(_.SWAP_SUGGESTED_TOKENS||[]).map(i=>s.find(u=>u.symbol===i)).filter(i=>!!i).filter(i=>!r.some(u=>u.address===i.address));e.suggestedTokens=[...r,...l]}catch{e.tokens=[],e.popularTokens=[],e.suggestedTokens=[]}finally{e.tokensLoading=!1}},async getAddressPrice(n){var i,u;const t=e.tokensPriceMap[n];if(t)return t;const o=await v.fetchTokenPrice({addresses:[n]}),s=(o==null?void 0:o.fungibles)||[],c=[...e.tokens||[],...e.myTokensWithBalance||[]],r=(i=c==null?void 0:c.find(p=>p.address===n))==null?void 0:i.symbol,d=((u=s.find(p=>p.symbol.toLowerCase()===(r==null?void 0:r.toLowerCase())))==null?void 0:u.price)||0,l=parseFloat(d.toString());return e.tokensPriceMap[n]=l,l},async getNetworkTokenPrice(){var c;const{networkAddress:n}=a.getParams(),o=(c=(await v.fetchTokenPrice({addresses:[n]}).catch(()=>(g.showError("Failed to fetch network token price"),{fungibles:[]}))).fungibles)==null?void 0:c[0],s=(o==null?void 0:o.price.toString())||"0";e.tokensPriceMap[n]=parseFloat(s),e.networkTokenSymbol=(o==null?void 0:o.symbol)||"",e.networkPrice=s},async getMyTokensWithBalance(n){const t=await R.getMyTokensWithBalance(n),o=N.mapBalancesToSwapTokens(t);o&&(await a.getInitialGasPrice(),a.setBalances(o))},setBalances(n){const{networkAddress:t}=a.getParams(),o=w.state.activeCaipNetwork;if(!o)return;const s=n.find(c=>c.address===t);n.forEach(c=>{e.tokensPriceMap[c.address]=c.price||0}),e.myTokensWithBalance=n.filter(c=>c.address.startsWith(o.caipNetworkId)),e.networkBalanceInUSD=s?T.multiply(s.quantity.numeric,s.price).toString():"0"},async getInitialGasPrice(){var t,o;const n=await N.fetchGasPrice();if(!n)return{gasPrice:null,gasPriceInUSD:null};switch((o=(t=w.state)==null?void 0:t.activeCaipNetwork)==null?void 0:o.chainNamespace){case P.CHAIN.SOLANA:return e.gasFee=n.standard??"0",e.gasPriceInUSD=T.multiply(n.standard,e.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(e.gasFee),gasPriceInUSD:Number(e.gasPriceInUSD)};case P.CHAIN.EVM:default:const s=n.standard??"0",c=BigInt(s),r=BigInt(O),d=I.getGasPriceInUSD(e.networkPrice,r,c);return e.gasFee=s,e.gasPriceInUSD=d,{gasPrice:c,gasPriceInUSD:d}}},async swapTokens(){var r,d,l;const n=(r=w.getAccountData())==null?void 0:r.address,t=e.sourceToken,o=e.toToken,s=T.bigNumber(e.sourceTokenAmount).gt(0);if(s||a.setToTokenAmount(""),!o||!t||e.loadingPrices||!s||!n)return;e.loadingQuote=!0;const c=T.bigNumber(e.sourceTokenAmount).times(10**t.decimals).round(0);try{const i=await v.fetchSwapQuote({userAddress:n,from:t.address,to:o.address,gasPrice:e.gasFee,amount:c.toString()});e.loadingQuote=!1;const u=(l=(d=i==null?void 0:i.quotes)==null?void 0:d[0])==null?void 0:l.toAmount;if(!u){z.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");return}const p=T.bigNumber(u).div(10**o.decimals).toString();a.setToTokenAmount(p),a.hasInsufficientToken(e.sourceTokenAmount,t.address)?e.inputError="Insufficient balance":(e.inputError=void 0,a.setTransactionDetails())}catch(i){const u=await N.handleSwapError(i);e.loadingQuote=!1,e.inputError=u||"Insufficient balance"}},async getTransaction(){const{fromCaipAddress:n,availableToSwap:t}=a.getParams(),o=e.sourceToken,s=e.toToken;if(!(!n||!t||!o||!s||e.loadingQuote))try{e.loadingBuildTransaction=!0;const c=await N.fetchSwapAllowance({userAddress:n,tokenAddress:o.address,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:o.decimals});let r;return c?r=await a.createSwapTransaction():r=await a.createAllowanceTransaction(),e.loadingBuildTransaction=!1,e.fetchError=!1,r}catch{A.goBack(),g.showError("Failed to check allowance"),e.loadingBuildTransaction=!1,e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},async createAllowanceTransaction(){const{fromCaipAddress:n,sourceTokenAddress:t,toTokenAddress:o}=a.getParams();if(!(!n||!o)){if(!t)throw new Error("createAllowanceTransaction - No source token address found.");try{const s=await v.generateApproveCalldata({from:t,to:o,userAddress:n}),c=L.getPlainAddress(s.tx.from);if(!c)throw new Error("SwapController:createAllowanceTransaction - address is required");const r={data:s.tx.data,to:c,gasPrice:BigInt(s.tx.eip155.gasPrice),value:BigInt(s.tx.value),toAmount:e.toTokenAmount};return e.swapTransaction=void 0,e.approvalTransaction={data:r.data,to:r.to,gasPrice:r.gasPrice,value:r.value,toAmount:r.toAmount},{data:r.data,to:r.to,gasPrice:r.gasPrice,value:r.value,toAmount:r.toAmount}}catch{A.goBack(),g.showError("Failed to create approval transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}}},async createSwapTransaction(){var d;const{networkAddress:n,fromCaipAddress:t,sourceTokenAmount:o}=a.getParams(),s=e.sourceToken,c=e.toToken;if(!t||!o||!s||!c)return;const r=(d=D.parseUnits(o,s.decimals))==null?void 0:d.toString();try{const l=await v.generateSwapCalldata({userAddress:t,from:s.address,to:c.address,amount:r,disableEstimate:!0}),i=s.address===n,u=BigInt(l.tx.eip155.gas),p=BigInt(l.tx.eip155.gasPrice),f=L.getPlainAddress(l.tx.to);if(!f)throw new Error("SwapController:createSwapTransaction - address is required");const S={data:l.tx.data,to:f,gas:u,gasPrice:p,value:BigInt(i?r??"0":"0"),toAmount:e.toTokenAmount};return e.gasPriceInUSD=I.getGasPriceInUSD(e.networkPrice,u,p),e.approvalTransaction=void 0,e.swapTransaction=S,S}catch{A.goBack(),g.showError("Failed to create transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){g.showLoading("Approve limit increase in your wallet"),A.replace("SwapPreview")},async sendTransactionForApproval(n){var c,r,d;const{fromAddress:t,isAuthConnector:o}=a.getParams();e.loadingApprovalTransaction=!0,o?A.pushTransactionStack({onSuccess:a.onEmbeddedWalletApprovalSuccess}):g.showLoading("Approve limit increase in your wallet");try{await D.sendTransaction({address:t,to:n.to,data:n.data,value:n.value,chainNamespace:P.CHAIN.EVM}),await a.swapTokens(),await a.getTransaction(),e.approvalTransaction=void 0,e.loadingApprovalTransaction=!1}catch(l){const i=l;e.transactionError=i==null?void 0:i.displayMessage,e.loadingApprovalTransaction=!1,g.showError((i==null?void 0:i.displayMessage)||"Transaction error"),B.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:(i==null?void 0:i.displayMessage)||(i==null?void 0:i.message)||"Unknown",network:((c=w.state.activeCaipNetwork)==null?void 0:c.caipNetworkId)||"",swapFromToken:((r=a.state.sourceToken)==null?void 0:r.symbol)||"",swapToToken:((d=a.state.toToken)==null?void 0:d.symbol)||"",swapFromAmount:a.state.sourceTokenAmount||"",swapToAmount:a.state.toTokenAmount||"",isSmartAccount:M(P.CHAIN.EVM)===F.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(n){var d,l,i,u,p,f,S,h,y,b,C,G;if(!n)return;const{fromAddress:t,toTokenAmount:o,isAuthConnector:s}=a.getParams();e.loadingTransaction=!0;const c=`Swapping ${(d=e.sourceToken)==null?void 0:d.symbol} to ${T.formatNumberToLocalString(o,3)} ${(l=e.toToken)==null?void 0:l.symbol}`,r=`Swapped ${(i=e.sourceToken)==null?void 0:i.symbol} to ${T.formatNumberToLocalString(o,3)} ${(u=e.toToken)==null?void 0:u.symbol}`;s?A.pushTransactionStack({onSuccess(){A.replace("Account"),g.showLoading(c),E.resetState()}}):g.showLoading("Confirm transaction in your wallet");try{const U=[(p=e.sourceToken)==null?void 0:p.address,(f=e.toToken)==null?void 0:f.address].join(","),m=await D.sendTransaction({address:t,to:n.to,data:n.data,value:n.value,chainNamespace:P.CHAIN.EVM});return e.loadingTransaction=!1,g.showSuccess(r),B.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:((S=w.state.activeCaipNetwork)==null?void 0:S.caipNetworkId)||"",swapFromToken:((h=a.state.sourceToken)==null?void 0:h.symbol)||"",swapToToken:((y=a.state.toToken)==null?void 0:y.symbol)||"",swapFromAmount:a.state.sourceTokenAmount||"",swapToAmount:a.state.toTokenAmount||"",isSmartAccount:M(P.CHAIN.EVM)===F.ACCOUNT_TYPES.SMART_ACCOUNT}}),E.resetState(),s||A.replace("Account"),E.getMyTokensWithBalance(U),m}catch(U){const m=U;e.transactionError=m==null?void 0:m.displayMessage,e.loadingTransaction=!1,g.showError((m==null?void 0:m.displayMessage)||"Transaction error"),B.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:(m==null?void 0:m.displayMessage)||(m==null?void 0:m.message)||"Unknown",network:((b=w.state.activeCaipNetwork)==null?void 0:b.caipNetworkId)||"",swapFromToken:((C=a.state.sourceToken)==null?void 0:C.symbol)||"",swapToToken:((G=a.state.toToken)==null?void 0:G.symbol)||"",swapFromAmount:a.state.sourceTokenAmount||"",swapToAmount:a.state.toTokenAmount||"",isSmartAccount:M(P.CHAIN.EVM)===F.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken(n,t){return I.isInsufficientSourceTokenForSwap(n,t,e.myTokensWithBalance)},setTransactionDetails(){const{toTokenAddress:n,toTokenDecimals:t}=a.getParams();!n||!t||(e.gasPriceInUSD=I.getGasPriceInUSD(e.networkPrice,BigInt(e.gasFee),BigInt(O)),e.priceImpact=I.getPriceImpact({sourceTokenAmount:e.sourceTokenAmount,sourceTokenPriceInUSD:e.sourceTokenPriceInUSD,toTokenPriceInUSD:e.toTokenPriceInUSD,toTokenAmount:e.toTokenAmount}),e.maxSlippage=I.getMaxSlippage(e.slippage,e.toTokenAmount),e.providerFee=I.getProviderFee(e.sourceTokenAmount))}},a=W(E);export{a as S};
